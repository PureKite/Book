= 코드의 구린내

.중복 코드(Duplicated Code)
- 똑같은 코드가 두 군데 이상 있을 때는 그 부분을 하나로 통일하면 프로그램이 개선
- 한 클래스의 두 메서드 안에 같은 코드가 들어 있는 경우 => 메서드 추출 기법
- 한 클래스의 두 하위클래스에 같은 코드가 들어 있는 경우 => 메서드 추출 기법을 적용해서 중복을 없앤 후 메서드 상향 기법
- 코드가 똑같지 않고 비슷하다면 => 메서드 추출 기법을 적용해서 같은 부분과 다른 부분을 분리 => 템플릿 메서드 형성
- 두 메서드가 알고리즘만 다르고 기능이 같다면 개발자는 그 두 알고리즘 중에서 더 간단한 것을 택해 알고리즘 전환을 적용
- 중복 코드가 메서드 가운데에 있다면 주변 메서드 추출을 적용
- 서로 상관없는 두 클래스 안에 중복 코드가 있을 때는 한 클래스 안의 중복 코드를 클래스 추출이나 모듈 추출을 적용하거나 중복 코드를 메서드로 만든 후 그 메서드를 두 클래스 중 하나에 넣고 다른 클래스에서 그 메서드를 호출하거나, 코드를 빼내어 만든 메서드를 제 3의 클래스에 넣고 그걸 두 클래스에서 호출하는 방법

.장황한 메서드(Long Method)
- 짧은 메서드를 이해하기 쉽게 할려면 메서드명을 잘 정해야 함
- 메서드를 줄이기 위해서는 메서드 추출(Extract Method) 기법 적용
** 메서드에서 하나로 묶으면 좋을 만한 부분들을 찾아내어 메서드로 만드는 것
** 메서드에 매개변수와 임시변수가 많으면 메서드 추출하기 까다로움
*** 임시변수 => 메서드 호출로 전환(Replace Temp with Query) 기법, 메서드 체인으로 전환(Replace Temp with Chain) 기법
*** 길게 열거된 매개변수 => 매개변수 세트를 객체로 전환(Introduce Parameter Object), 객체를 통째로 전달(Preserve Whole Object) 기법
- 코드를 여러 덩어리로 분리하려면? 기능 설명이 주석으로 처리된 코드 구간을 메서드로 만들기
** 이 때 메서드명은 주석에 설명된 기능을 참고해서 정하면 됨
** 한 줄밖에 안되는 코드라도 별도의 주석이 달려 있을 정도로 다른 기능을 수행한다면 메서드로 추출
- 조건문과 루프도 메서드로 빼야 함
** 조건문을 추출 => 조건문 쪼개기(Decompose Conditional) 기법
** 루프 => 컬렉션 클로저 메서드로 전환(Replace Loop with Collection Closure Method)을 실시 => 클로저 메서드 호출과 클로저 자체에 메서드 추출을 실시

.방대한 클래스(Large Class)
- 기능이 지나치게 많은 클래스에는 보통 엄청난 수의 인스턴스 변수가 들어 있음
- 클래스에 인스턴스 변수가 너무 많으면 중복 코드가 반드시 존재하게 마련
- 클래스 추출(Extract Class) => 수많은 인스턴스 변수를 하나로 묶을 수 있음
** 한 클래스 안의 일부 변수가 접두어나 접미어가 같다면 하나의 클래스로 추출하는게 좋음
- 하위클래스 추출(Extract Subclass) => 하위클래스로 추출하는 것이 적합할 때
- 모듈 추출(Extract Module) => 추출할 클래스가 대라자로 부적절할 것 같을 때
- 인스턴스 변수를 계속해서 모두 사용하지 않는 클래스 => 클래스 추출, 모듈 추출, 하위클래스 추출 중 하나를 여러 번 적용
- 코드 분량이 너무 방대한 클래스 => 중복 코드를 없애는 것
** 클래스 추출, 모듈 추출, 하위클래스 추출 중 하나 실시
** 클라이언트가 그 클래스를 어떻게 사용하게 할지 결정하고, 그러한 각 사용 방법마다 인터페이스 추출(Extract Interface)
** 만약 방대한 클래스가 GUI 클래스라면 데이터와 기능을 서로 다른 도메인 객체로 옮겨야 할 수도 있음
*** 두 곳에 있는 일부 중복 데이터는 놔두고 그 데이터와 싱크를 유지해야할 수도 있음 => 관측 데이터 복제(Duplicate Observed Data) 기법 실시하면 해결

.과다한 매개변수(Long Parameter List)
- 객체를 사용할 때는 메서드에 필요한 모든 데이터를 전달하는 게 아니라 그 모든 데이터를 가져올 수 있는 메서드만 전달하면 됨
** 메서드가 필요로 하는 각종 데이터는 그 메서드가 속한 클래스에 들어 있음
- 매개변수 세트가 간결하다는 것은 장점
** Why? 매개변수 세트가 길면 서로 일관성이 없어지거나 사용이 불편해지고, 더 많은 데이터가 필요해질 때마다 계속 수정해야 하기 때문에 매개변수들을 이해하기 어려움
- 이미 알고 있는 객체에 요청하여 한 매개변수에 들어 있는 데이터를 가져올 수 있을 때 => 매개변수 세트를 메서드로 전환(Replace Parameter with Method)
** 이 객체는 인스턴스 변수일 수도 있고 다른 매개변수일 수도 있음
- 객체에 있는 데이터 세트를 가져온 후, 데이터 세트를 그 객체 자체로 전환하려면 객체를 통째로 전달(Preserve Whole Object) 적용
- 여러 데이터 항목에 논리적 객체가 없다면 매개변수 세트를 객체로 전환(Introduce Parameter Object) 적용
- 이 기법들을 적용할 때 예외가 하나 있음
** 호출되는 객체가 호출 객체에 의존하면 안 될 때
** 이럴 때는 데이터를 개별적으로 빼서 매개변수로 전달하는 것이 바람직하지만, 어려움이 따름
** 나열된 매개변수 세트가 너무 길거나 자주 바뀐다면 불가피하게 종속 구조를 유지하는 것도 생각해봐야 함

.수정의 산발(Divergent Change)
- 개발자는 소프트웨어를 수정하기 쉽게 구성
- 한 클래스가 다양한 원인 때문에 다양한 방식으로 자주 수정될 때
** 얘) 새 데이터베이스를 생성할 때마다 이 3개의 메서드를 수정해야 하고, 새 금융 상품을 추가할 때마다 이 4개의 메서드를 수정해야 하네
*** 하나의 클래스를 여러 개의 변형 객체로 분리하는 것이 좋음 => 각 객체는 한 종류의 수정에 의해서만 변경됨
- 특정 원인으로 인해 변하는 모든 부분을 찾은 후 클래스 추출을 적용

.기능의 산재(Shotgun Surgery)
- 수정의 산발과 비슷하지만 정 반대
** 수정의 산발 => 한 클래스에 여러 수정이 발생하는 문제
** 기능의 산재 => 하나의 수정으로 여러 클래스가 바뀌게 되는 문제
** 둘 중 어느 것이든 수정과 클래스가 일대일 대응되게 깔끔히 정리해야 함
- 수정할 때마다 여러 클래스에서 수많은 자잘한 부분을 고쳐야 한다면 이 문제를 의심
- 메서드 이동과 필드 이동을 적용해서 수정할 부분들을 전부 하나의 클래스 안에 넣어야 함

.잘못된 소속(Feature Envy)
- 객체의 핵심 : 데이터와 그 데이터에 사용되는 프로세스를 한 데 묶는 기술이라는 점
- 소속이 잘못된 메서드는 더 많이 접근하는 클래스에 들어가는 것이 마땅하니, 메서드 이동 기법 실시해서 더 자주 접근하는 클래스로 옮겨야 함
- 메서드의 일부분만 소속이 잘못된 경우 => 메서드 추출 - 메서드 이동 적용
- 한 메서드가 여러 클래스에 들어 있는 기능을 이용할 ? 메서드 추출을 실시해서 여러 부분으로 쪼개어 작업이 더 쉬워짐
- 이 규칙을 따르지 않는 복잡한 패턴
** 전략 패턴
** 방문자 패턴
** 자가 위임 패턴
** 위의 패턴들은 수정의 산발이 의심될 때의 해결책(함께 수정되는 것들을 하나로 뭉치는 것)
** 전략 패턴과 방문자 패턴은 재정의가 필요한 일부 기능을 따로 빼내기 때문에 기능을 수정하기는 쉬워지지만, 인다이렉션이 늘어나는 단점이 있음

.데이터 뭉치(Data Clumps)
- 두 클래스에 들어 있는 인트선스 변수나 여러 메서드 시그니처에 들어 있는 매개변수처럼, 동일한 3 ~ 4개의 데이터 항목이 여러 위치에 몰려 있는 경우
** 이런 데이터 뭉치는 객체로 만들기
- 데이터 뭉치가 필드처럼 보이는 부분 찾기 => 그 필드들을 대상으로 클래스 추출 => 메서드 시그니처를 대상으로 매개변수 세트를 객체로 전환, 객체를 통째로 전환 기법
** 새로 생긴 객체의 속성들 중 일부만 이용하는 데이터 뭉치라도 효과를 볼 수 있음
** 여러 데이터 값 중 하나를 삭제했을 때 나머지 데이터 값들이 제대로 돌아가지 않는다면 그 객체를 없애고 새로 만들어야 함
- 수행하고 나면 잘못된 소속(Feature Envy)의 구린내가 풍기는 부분들을 찾을 수 있음

.강박적 기본 타입 사용(Primitive Obsession)
- 대개 프로그래밍 환경을 구성하는 데이터는 두 종류
** 레코드 타입 : 데이터를 의미 있는 그룹들로 묶어 구조화
** 기본 타입 : 초석
- 객체의 장점 : 기본 타입 클래스와 응용 클래스 간의 경계를 허문다는 점
- 자바에는 숫자에 대한 기본 타입이 존재하지만, 다른 언어에서 기본 타입으로 존재하는 문자열과 날짜가 자바에선 클래스로 존재
- 데이터 값을 객체로 전환을 실시
- 데이터 값이 분류 부호일 땐 그 값이 기능에 영향을 주지 않는다면 분류 부호를 클래스로 전환
- 조건문에 분류 부호가 사용도리 땐 분류 부호를 하위클래스로 전환 or 분류 부호를 상태/전략 패턴으로 전환 기법 적용
- 뭉쳐 다녀야 할 여러 개의 필드가 있다면 클래스 추출 기법
- 기본 타입이 매개변수 세트에 들어 있다면 매개변수 세트를 객체로 전환 기법
- 배열 때문에 불편하다면 배열을 객체로 전환 기법

.switch 문(Switch Statements)
- switch문의 단점 : 반드시 중복이 생긴다는 점
- switch => 다형성, 즉 재정의를 이용하는 것
- 대부분의 switch문은 재정의로 바꿔야 함
- 문제는 재정의를 넣을 위치
** 분류 부호가 흔히 사용되는데, 그럴 땐 분류 부호 값이 들어 있는 메서드나 클래스가 있어야 함
*** 메서드 추출 실시
*** switch문을 메서드로 빼낸 후 메서드 이동 실시
*** 그 메서드를 재정의해야 할 클래스에 옮겨 넣기
*** 그와 동시에 분류 부호를 하위클래스로 전환 기법 or 분류 부호를 상태/전략 패턴으로 전환
- 상속 구조를 만들었따면 조건문을 재정의로 전환
- 매개변수를 메서드로 변환을 적용
** 하나의 메서드에 영향을 미치는 case 문이 2 ~ 3개 밖에 없고 나중에 그 모든 case 문을 수정할 일이 없을 것 같으면, 재정의로 전환하는 것은 과함
- 조건문이 들어 있는 여러 case 문 중 하나가 널 일때는 Null 검사를 Null 객체에 위임을 실시

.평행 상속 걔층(Parallel Inheritance Hierarchies)
- 기능의 산재의 특수한 상황
- 한 클래스의 하위클래스를 만들 때마다 매번 다른 클래스의 하위클래스도 만들어야 함
- 서로 다른 두 상속 계층의 클래스명 접두어가 같으면 의심
- 중복 코드 부분을 제거하려면 보통은 한 상속 계층의 인스턴스가 다른 상속 계층의 인스턴스를 참조하게 만들면 됨
** 메서드 이동과 필드 이동 실시

.직무유기 클래스(Lazy Class)
- 하나의 클래스를 작성할 때마다 유지관리와 이해하기 위한 비용이 추가
** 비용만큼의 기능을 수행하지 못하는 비효율적 클래스는 없어야 함
- 직무유기 클래스란?
** 기존에는 비용 대비 효율성이 좋았으나 리팩토링 실시로 인해 기능이 축소된 클래스
*** 계층 병합(Collapse Hierarchy) 실시
** 수정할 계획으로 작성했으나 수정을 실시하지 않아 쓸모없어진 클래스
*** 클래스 내용 직접 삽입(Inline Class) or 모듈 내용 직접 삽입(Inline Module) 기법 적용

.막연한 범용 코드(Speculative Generality)
- 필요 없는 기능을 수행하고자 온갖 호출과 case 문을 넣으려 하는 순간 막연한 범용 코드의 구린내가 발생
** 별다른 기능이 없는 클래스나 모듈이 있다면 계층 병합
** 불필요한 위임을 제거하려면 클래스 내용 직접 삽입
** 메서드에 사용되지 않는 매개변수가 있으면 매개변수 제거
** 메서드명이 이상하다면 메서드명 변경 실시
- 메서드나 클래스가 오직 테스트 케이스에만 사용된다면 구린내를 풍기는 유력한 용의자로 막연한 범용 코드를 지목
** 그것과 그것을 실행하는 테스트 케이스를 모두 삭제

.임시 필드(Temporary Field)
- 어떤 객체 안에 인스턴스 변수가 특정 상황에서만 할당되는 경우
- 떠돌이 변수들이 서식할 집을 마련해주려면 클래스 추출을 실시
** 작성한 클래스에 그 변수들과 관련된 코드를 전부 넣어야 함
- Null 검사를 널 객체에 위임을 실시해서 그 변수들의 값이 올바르지 않을 경우를 대비한 대체 컴포넌트를 작성하면 경우에 따라 조건문 코드를 없앨 수 있음
- When? 복잡한 알고리즘에 여러 변수를 사용해야 할 때
** 인스턴스 변수와 그 변수를 사용하는 메서드 전부에 대해 클래스 추출 적용

.메시지 체인(Message Chains)
- 클라이언트가 한 객체에서 제 2의 객체를 요청하면, 제 2의 객체가 제 3의 객체를 요청하고, 제 3의 객체가 제 4의 객체를 요청하는 식으로 연쇄적 요청이 발생하는 문제점
- 대리 객체 은폐(Hide Delegate)를 실시
** 원칙적으로 체인을 구성하는 모든 객체에 적용할 수 있지만, 모든 중간 객체가 중개 메서드로 변해서 과잉 중개 메서드의 구랜내를 풍기는 문제가 흔히 발생
** 결과 객체가 어느 대상에 사용되는지를 알아내는 방법이 더 나음
** 그렇게 알아낸 객체가 사용되는 코드 부분을 메서드 추출을 통해 별도의 메서드로 빼낸 후 메서드 이동을 실시해서 체인 아래로 밀어낼 수 있는지 여부를 검사
*** 만약 체인에 속한 객체 중 한 객체의 여러 클라이언트가 나머지 객체들에 왕래한다면 그 기능을 수행하는 메서드를 추가하면 됨

.과잉 중개 메서드(Middle Man)
- 캡슐화 : 내부의 세부적인 처리를 외부에서 볼 수 없게 은폐하는 작업
** 대개 위임이 수반됨
- 대개 위임이 지나치면 문제가 됨
- 어떤 클래스의 인터페이스를 보니까 그 안의 절반도 넘는 메서드가 기능을 다른 클래스에 위임하고 있다면, 과잉 중개 메서드 제거를 실시해 원리가 구현된 객체에 직접 접근
- 일부 메서드에 별 기능이 없다면 메서드 내용 직접 삽입을 실시해서 그 메서드들의 내용을 호출 객체에 직접 삽입
- 부수적인 기능이 있다면 위임을 상속으로 전환(Replace Delegation with Inheritance) 기법 실시
** 중개 메서드를 실제 객체의 하위클래스로 전환
- 위의 과정을 수행하면 모든 위임을 추적하지 않고 기능을 확장할 수 있음

.지나친 관여(Inappropriate Intimacy)
- 클래스끼리 관계가 지나치게 밀접한 나머지 서로의 은밀한 부분(private)을 알아내느라 과도한 시간을 낭비할게 될 때
** 클래스는 엄격하고 절제된 규칙을 따라야 함
- 서로 지나치게 관여하는 클래스는 갈라놔야함
** 메서드 이동과 필드 이동을 실시
** 클래스의 양방향 연결을 단방향으로 전환(Change Bidirectional Association to Unidirectional)
** 클래스 추출을 실시해서 공통 필요 부분을 별도의 안전한 클래스로 빼내면 됨
** 대리 객체 은폐(Hide Delegate)를 실시하여 다른 클래스가 중개 메서드 역할을 하게 만듦
- 상속으로 인해 지나친 관여가 발생하는 경우
** 상위클래스에서 하위클래스를 빼내야 할 경우에는 상속을 위임을 전환(Replace Inheritance with Delegation)

.인터페이스가 다른 대용 클래스(Alternative Classes with Different Interfaces)
- 기능은 같은데 시그너처가 다른 메서드에는 메서드명 변경
- 클래스에 여전히 충분한 기능이 구현되어 있지 않기 때문에 대체로 이 기법만 적용해선 충분하지 않음
- 프로토콜이 같아질 때가지 메서드 이동을 실시해서 기능을 해당 클래스로 옮겨야 함
** 코드를 너무 여러 번 옮겨야 한다면 상위클래스 추출을 실시

.미흡한 라이브러리 클래스(Incomplete Library Class)
- 라이브러리 클래스를 원하는 기능을 수행하게 수정하는 것이 보통은 불가능
- 라이브러리 클래스에 넣어야 할 메서드가 두 개뿐이라면 외래 클래스에 메서드 추가 기법
- 부가 기능이 많을 때는 국소적 상속확장 클래스 사용

.데이터 클래스(Data Class)
- 데이터 클래스? 필드와 필드 읽기/쓰기 메서드만 들어 있는 클래스
** 데이터 보관만 담당하며, 구체적 데이터 조작은 다른 클래스가 수행
- 필드 캡슐화 기법 실시
- 컬렉션 필드가 있으면 그 필드가 적절히 캡슐화되어 있는지 확인해서 캡슐화되어 있지 않다면 컬렉션 캡슐화 기법 적용
- 변경되지 않아야 하는 필드에는 쓰기 메서드 제거를 적용
- 읽기/쓰기 메서드가 다른 클래스에 의해 사용되는 부분을 찾아서, 메서드 이동을 실시하여 기능을 그 데이터 클래스로 옮겨야 함
- 메서드 전체를 옮길 수 없다면 메서드 추출을 실시해서 옮길 수 있는 메서드를 작성하면 됨
- 읽기/쓰기 메서드에 메서드 은폐를 적용

.방치된 상속물(Refused Bequest)
- 상속받은 메서드나 데이터가 하위클래스에서 더 이상 쓰이지 않거나 필요 없을 땐?
** 하위클래스는 상속물을 전부 받아 그 중에서 필요한 것 외엔 방치해버리는 문제가 생김
- 기존에는 이 문제의 원인이 잘못된 계층 구조 때문이라고 설명
** 새 대등 클래스를 작성하고 메서드 하향과 필드 하향을 실시해서 사용되지 않는 모든 메서드를 그 형제 클래스에 몰아넣어야 함
- 이 문제는 심각하지 않은 경우가 대부분이기 때문에 리팩토링이 별로 필요하지 않음
** 저자가 일부 기능을 언제든 재사용하고자 하위클래스로 몰아넣는 작업을 하는데 매우 효과적
- 방치된 상속물의 구린내는 하위클래스가 기능을 재사용하지만 상위클래스의 인터페이슬르 지원하지 않을 때 훨씬 심하게 풍김
** 인터페이스를 거부하는 것은 심각한 문제 => 상속을 위임으로 전환해 계층 구조를 없애야 함

.불필요한 주석(Comments)
- 엄청난 양의 주석이 달린 코드를 보면 해당 코드의 구린내를 가리기 위해 존재하는 경우가 상당히 많음
- 메서드가 이미 추출된 상태임에도 기능을 설명할 주석이 여전히 필요하다면, 메서드명 변경을 실시
- 시스템의 필수적인 상태에 고나해 약간의 규칙을 설명해야 할 때는 어선셜 넣기(Introduce Assertion)를 실시
- 주석은 무슨 작업을 해야 좋을지 모를 때 or 어떤 코드를 넣은 이유를 메모해 놓을 경우
