= Chapter02 리팩토링 개론

.리팩토링은 무엇인가
- 명사 : 겉으로 드러나는 기능은 그대로 둔 채, 알아보기 쉽고 수정하기 간편하게 소프트웨어 내부를 수정하는 작업
- 동사 : 리팩토링 기법을 연달아 적용해서 겉으로 드러나는 기능은 그대로 둔 채 소프트웨어 구조를 변경
- 리팩토링의 목적? 소프트웨어를 더 이해하기 쉽고 수정하기 쉽게 만드는 것
** 리팩토링을 수행하면 겉으로 드러나는 기능에 거의 또는 아예 영향을 주지 않은 채 소프트웨어의 각종 기능을 변경할 수 있음
- 리팩토링은 성능 최적화와 상반됨
** 성능 최적화를 수행하면 코드를 파악하기 더 어려워질 때가 많지만, 필요한 성능을 얻으려면 어쩔 수 없음
- 리팩토링하기 전의 소프트웨어 기능은 리팩토링을 수행하고 나서도 그대로이며, 최종 사용자나 다른 프로그래머는 그 소프트웨어에 변화가 있음을 눈치채지 못함
- 소프트웨어 개발에 리팩토링을 적용할 때 기능 추가와 리팩토링이라는 별개의 두 작업에 시간을 분배해야함
** 기능을 추가할 땐 코드를 수정하지 말고 기능만 추가
** 진행 상태를 파악하려면 테스트를 추가하고 그 테스트들이 제대로 되는지 알아내면 됨
** 리팩토링할 때는 코드를 추가하지 말고 코드 구조 개선만 해야 함. 오로지 코드 구조만 수정해야 함
** 인터페이스가 변경되어 그에 맞게 코드를 고치는 것이 불가피할 땐 테스트만 변경
- 각 작업이 완료될 때까지는 반드시 현재 하고 있는 작업의 일관성을 유지해야 함

.리팩토링은 왜 해야 하나
- 소프트웨어 설계가 개선되니까
** 리팩토링을 실시하지 않으면 프로그램 설계는 점점 노후됨
** 부적절한 위치에 있는 코드를 제거하는 것
** 코드 설계가 깔끔하지 않으면 보통 기능이 같은 코드가 여기저기 중복되어 있어서 쓸데없이 코드만 길어짐 => 그런 중복 코드를 없애는 것
** 중복 코드 제거는 깔끔한 설계의 필수 요건
- 소프트웨어를 이해하기가 더 쉬워지니까
** 프로그래밍은 컴퓨터와 나누는 대화라는 관점에서 프로그래밍에서는 개발자가 원하는 바를 정확히 명령하는 것이 중요
** 개발자가 프로그램을 제대로 실행되게 만드는 데만 집착한 나머지, 그  코드를 나중에 수정하게 될 다른 개발자에 대해 고려하지 않는 점이 문제의 원인
- 버그를 찾기가 쉬워지니까
** 코드 리팩토링을 실시하면 코드 기능을 기본적으로 이해할 수 있으며 그 새로운 깨달음을 즉시 코드에 반영
** 프로그램 구조를 명료하게 만들어서 내가 특정한 전제들이 확실해지면 버그를 놓치는 것이 불가능할 정도가 됨
- 프로그래밍 속도가 빨라지니까
** 리팩토링이 코드를 신속하게 개발할 수 있게 만들어 줌
** 깔끔한 설계는 전적으로 신속한 개발을 모목적으로 함
** 설계가 깔끔하지 않으면 나중에 개발 속도가 떨어짐
** 새 기능 추가나 버그 찾기에 많은 시간을 낭비하게 됨
** 깔끔한 설계는 소프트웨어 개발 속도를 적절히 유지하는 데 꼭 필요

.리팩토링은 어떨 때 필요한가
- 같은 작업의 삼진 아웃 때
** 같은 작업을 3번째 반복하게 됐을 때 리팩토링을 실시
- 기능을 추가할 때
** 첫 번째 상황 : 소프트웨어에 새 기능을 추가해야 할 때
** 이 시점에 해야 하는 이유 : 코드를 이해하기 쉽게 만들기 위해서
** 두 번째 상황 : 설꼐가 지저분해서 어떤 기능을 추가하기 힘들 때
** "이 코드를 이런 식으로 설계했더라면 이 기능을 추가하기 쉬웠을 텐데"하는 생각이 들 때 과거의 잘못에 연연하지 않고 리팩토링을 실시해서 설계 수정
- 버그를 수정할 때
** 주로 코드를 이해하기 쉽게 만들려고 리팩토링 실시
** 코드의기능을 파악하려다 이해하기 힘들면 이해하기 쉽게 만들려고 리팩토링 실시
** 버그 리포트가 입수되었을 때 => 버그가 있는 줄도 몰랐을 만큼 코드가 지저분하다는 반증
- 코드를 검수할 때
** 코드를 검수하는 동안 더 많은 이들의 기발한 아이디어를 제안받을 기회도 생김 => 다른 이들의 도움을 얻을 수 있음

.리팩토링의 호용성
- 프로그램이 지닌 가치
** 현재의 기능 : 프로그래밍할 때 개발자는 주로 현재 무슨 기능을 넣을지에 전념, 버그를 수정하든 새 기능을 추가하든 => 프로그램의 성능을 높임으로써 현재 기능의 가치를 높이는 일
** 미래의 기능 : 프로그램의 현재 기능은 그저 일부에 불과
- 프로그램은 4가지 상황에서 수정하기 힘들어짐
** 코드를 알아보기 힘들 때
** 중복된 로직이 들어 있을 때
** 추가 기능을 넣어야 해서 실행 중인 코드를 변경해야 할 때
** 조건문 구조가 복잡할 때

.인다이렉션과 리팩토링
- 인다이렉션은 양날의 검
** 한 부분을 둘로 쪼개면 관리할 부분이 늘어남
** 한 객체가 다른 객체에 작업을 위임하고 그 객체가 또 다른 객체에 작업을 위임하기 때문에 코드가 알아보기 힘들어질 수 있음
- 인다이렉션의 장점
** 로직을 공유 : 두 위치에서 호출되는 하위 메서드나 모든 하위클래스가 공유하는 상위클래스의 메서드 등이 있음. 이런 식으로 하나의 로직을 여러 곳에 공유할 수 있음
** 의도와 구현부를 따로 나타냄 : 클래스명과 메서드명을 정해서 의도한 바를 드러낼 수 있고, 클래스나 메서드의 내부 코드를 통해 그 의도를 어떻게 구현했는지 보여줄 수 있음. 내부 코드를 다시 더 잘게 쪼개어 의도적인 측면에서 작성했다면 그 코드의 구조에 대한 대부분의 주요 정보를 잘 드러내는 코드를 작성할 수 있음
** 수정 부분을 분리 : 한 객체를 두 위치에 사용했는데 두 경우 중 한 상황에 대해 동작을 수정해야 할 때 그 객체를 수정하면 두 상황이 모두 변경될 위험이 있음. 따라서 하위클래스를 만들고 변하는 경우에 참조하게 만들기 => 다르경우로 예기치 못하게 변할 위험을 감수하지 않고 클래스를 수정할 수 있음
** 조건문을 코드화 : 객체는 재정의 메시지라는 우수한 메커니즘이 존재해서 조건문을 유연하면서도 분명하게 표현할 수 있음. 조건문을 메시지로 바꾸면 중복 코드가 줄어들어 명료해지며 동시에 유연성도 높아짐

.리팩토링 관련 문제들
- 데이터베이스
** 수많은 비즈니스 애플리케이션은 바탕이 되는 데이터베이스 스키마와 강력히 결합되어 있음
** 데이터베이스 스키마와 객체 모델의 상호 의존성을 최소화하려고 시스템을 꼼꼼하게 계층구조로 제작했더라도, 데이터베이스 스키마를 수정하면 데이터도 이전해야 하는데, 시간도 오래 걸릴 뿐 아니라 위험성도 높음
** 이 문제를 해결하기 위해 객체 모델과 데이터베이스 모델 사이에 별도의 소프트웨어 계층을 두는 방법
*** 두 모델에 생긴 변경 사항을 따로 유지할 수 있어서 한 모델을 수정할 때 다르모델은 수정할 필요 없이 그저 중개 계층만 수정하면 됨
*** 중개 계층이 생기면 복잡하긴 하나 상당히 유연성이 생김 => 리팩토링을 실시하지 않더라도 데이터베이스가 여러 개이거나 개발자 본인에게 관리 권한이 없는 복합 데이터 베이스 모델일 경우 유연성으 매우 중요한 요소
*** 객체 모델의 일정 부분들이 변경될 가능성이 높다는 사실을 깨달았을 때 별도의 계층을 생성하면 됨
- 인터페이스 변경
** 객체의 장점 : 인터페이스를 건드리지 않고 내부의 구현 코드를 수정할 수 있다는 점
** 리팩토링에서 불안한 점 : 상당수의 리팩토링이 인터페이스를 건드린다는 것
*** 메서드명 변경 기법
** 인터페이스가 사용되는 부분을 찾는 게 불가능하거나 수정할 수 없을 경우에 문제가 생김
*** 한 번 배포 타입이 된 인터페이스는 안전하게 수정할 수 없으며 호출자만 수정하는 것이 불가능해지므로 더 복잡한 절차를 수행해야 함
** 어떤 리팩토링 기법이 배포 인터페이스를 건드릴 경우 개발자는 적어도 그 인터페이스를 사용하는 부분이 그 인터페이스 변경에 맞춰 수정되기 전까지는 기존 인터페이스와 새 인터페이스를 모두 그대로 유지시켜야 함
*** 기존 인터페이스가 새 인터페이스를 호출하게 하면 됨
*** 메서드명을 변경할 때는 기존 메서드가 새 메서드를 호출하게 수정해서 계속 유지되게 해야 함
** 꼭 필요할 때가 아니면 인터페이스를 published 타입으로 만들지 않기
*** 인터페이스 수정을 촉진하기 위해 팀원이 다른 사람의 코드를 수정할 수 있게 코드 소유권 정책을 수정해야 할 수 있음
*** 대체로 페어 프로그래밍을 이용하는 것이 바람직
- 리팩토링을 어렵게 하는 설계를 수정하는 일
** 설계 자체에 오류가 있을 때나 설계에 대한 결정이 나중에 바뀌었을 때, 혹은 수정하기 힘들 것 같은 민감한 부분일 때도 리팩토링으로 해결됨
** 프레임워크 선택이라든지 연동 기술 선택 같은 특정 설계적 판단을 배제한 채 리팩토링 공정은 어렵긴 해도 분명 가능
- 리팩토링하면 안 되는 상황
** 코드를 처음부터 새로 작성해야 할 때 => 기존 코드가 지극히 지저분해서 리팩토링은 가능하지만 차라리 완전히 새로 작성하는게 더 쉬울 때
** 코드가 돌아가지 않는다면 그건 완전히 새로 작성하라는 신호
** 절충안은 하나의 거대 소프트웨어를 강력한 캡슐화를 통해 여러 개의 컴포넌트로 나누는 것
*** 한 번에 한 개의 컴포넌트씩 리팩토링할지 코드를 새로 작성할지를 결정하면 됨
** 납기가 임박했을 때

.리팩토링과 설걔
* 리팩토링은 설계를 보완하는 특수한 역할을 함
* 설계는 기술 도면이고, 코드는 건설 작업, 그러나 소프트웨어는 실물의 기계와 달리 유연하며 하나부터 열까지 생각을 통해 이뤄짐
* 리팩토링을 실시하면 사전 설계는 해야 하지만, 사전 설계 과정에서 완벽한 솔루션을 찾을 필요 없이 적당한 솔루션만 생각하면 됨

.리팩토링과 성능
* 리팩토링을 실시하면 분명 소프트웨어는 더 느려지지만, 소프트웨어 성능을 더 간단히 조절할 수 있음
* 소프트웨어 성능을 올리려면 먼저 소프트웨어를 튜닝 가능하게 만들어 놓고 나중에 충분한 속도가 나오게 튜닝하는 것(철저한 실시간 환경을 제외한 모든 환경에 적용)
* 빠른 소프트웨어를 작성할 수 있는 일반적인 세 가지 방법
** 철저한 실시간 시스템에 주로 사용되는 시간 분배
*** 설계를 분해하면서 각 구성 요소에 시간이나 메모리 사용량 같은 자원별 예산을 할당하는 것
*** 컴퍼넌트는 할당된 시간을 상호 교환하는 방식은 허용되지만 예산을 초과해서는 안 됨
*** 방식의 핵심 : 철저한 성능 시간(프로그램 실행이 할당된 시간 내에 정확히 실행되어야 함)
*** 심박 조정기 같은 시스템에는 적절하지만 기업 정보 시스템을 비롯한 다른 시스템에 적용하기엔 지나침
** 성능에 꾸준한 관심을 갖는 것
*** 직관적이라는 장점이 있지만, 그다지 효과는 없음
*** 소프트웨어가 더 빨라진다면 그 정도는 감안할 수 있겠지만, 소프트웨어가 더 빨라지는 경우는 거의 없음
*** 성능 향상 코드가 프로그램 여기저기 널리게 되고, 각 부분의 향상은 해당 프로그램 기능에 국한
** 앞에서 언급한 90% 비율의 장점만 활용
*** 개발 절차 중 후기 단계에 있는 성능 최적화 전까지는 성능에 신경 쓰지 않고 프로그램을 잘 쪼개진 방식으로 제작하는 것
*** 성능 최적화 단계에서 그 프로그램을 튜닝하는 특수 절차를 따름
*** 우선 프로그램을 모니터링해서 그 프로그램이 시간과 공간을 소모하는 상황을 개발자에게 알려주는 프로파일러 하에서 프로그램을 실행
*** 각 부분에 동등한 최적화를 적용
*** 각 단계별 리팩토링이 끝났으면 컴파일과 테스트를 거친 후 다시 프로파일러를 실행 => 만족스런 성능이 나올 때까지 코드를 다시 수정
** 프로그램을 잘 쪼개면 두 가지 측면에서 이런 최적화 방식에 도움이 됨
*** 첫째, 성능 튜닝에 할애할 시간이 생김
*** 둘째, 프로그램을 잘 쪼개면 성능을 분석할 때 더 정밀한 분석이 가능해짐
