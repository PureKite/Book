= 테스트 작성

.자가 테스트 코드의 가치
- 자가 테스트 코드를 작성하지 않으면 버그를 찾기가 힘들다는 점
- 모든 테스트를 완전히 자동화하고 결과를 자체적으로 검사하게 하자
- 테스트 스위트는 버그를 찾는 시간을 획기적으로 줄여주는 강력한 버그 감지 도구
- 기능을 추가해야 할 때는 우선 테스트를 작성
** 테스트를 작성하면 그 기능을 추가하려고 해야 할 작업이 무엇인지 자문하게 됨
** 테스트를 작성하면 구현부가 아니라 인터페이스에 집중하게 됨
** 코딩을 완료하는 시점 => 테스트가 성공하는 시점
- 리팩토링엔 테스트가 필수

.JUnit 테스트 프레임워크
- JUnit 프레임워크는 아주 간단하면서도 테스트를 실습하는 데 필요한 주요 기능이 들어 있음
- 테스트를 자주 실행, 적어도 하루에 한 번은 실시하고, 컴파일할 때마다 테스트를 국소화
- 리팩토링할 때는 작업 중인 코드를 연습할 때 두 세개의 테스트만 실행
- assertEquals를 이용하면 객체 비교엔 equals() 함수를 사용하고 값 비교엔 == 연산자를 사용, 에러 문구를 출력할 수 있음
- 실패와 에러는 다름
** 실패 : 어설션 결과가 실패로 출력
** 에러 : 예기치 못한 예외가 출력
- 단위 테스트와 기능테스트
** JUnit은 단위 테스트용
** 단위테스트의 목적? 프로그래밍 생산성 향상(프로그래밍 생산성이 높아지면 부수적으로 품질 보증 부서의 업무 효율도 향상)
** 단위테스트는 매우 국소적이어서, 각 테스트 클래스는 하나의 패키지 안에서만 효력이 있음
** 기능테스트의 목적? 소프트웨어 전반이 제대로 돌아가는지 확인하는 것(품질 보증만 할 뿐 프로그래머의 생산성과는 무관)
** 기능 테스트는 시스템 전반을 최대한 블랙박스처럼 취급
** 버그 리포트를 받으면 우선 그 버그를 한눈에 볼 수 있게 출력하는 단위 테스트부터 작성

.테스트 추가
- 읽기 / 쓰기 메서드는 너무 간단해서 버그가 있을 확률이 거의 없음
- 완벽한 테스트를 작성하려다가 아예 테스트를 포기하느니, 차라리 불완전한 테스트를 작성해 실행하는 편이 나음
- 테스트에서 가장 힘든 일은 경계 조건을 찾는 것
** 파일 읽기 메서드에서 경계는 첫 글자, 마지막 글자, 마지막 글자 바로 뒤의 글자
** 잘못될 수 있는 경계 조건을 생각한 후, 그 상황에서의 테스트에 집중
- 경계 찾기에는 테스트를 실패하게 할 가능성이 있는 특수 조건을 찾는 작업도 포함
** 파일의 경우, 파일이 비어 있을 경우를 특수 조건으로 사용하는게 적절
- 테스트를 실시할 때는 반드시 예상한 에러가 제대로 발생하는지 검사
- 테스트는 위험이 있는 곳에만 집중
** 코드에서 복잡해지는 부분이 어딘지를 파악하고, 함수를 살펴보면서 에러 가능성이 높은 부분들을 생각
- 객체의 단점은 상속과 재정의로 인해 테스트할 조합이 너무 많아져서 테스트가 어려우질 수 있다는 점
** 나올 수 있는 모든 조합을 테스트하진 않고, 각 조합 후보 클래스만 테스트를 실시
- 테스트 코드는 복사해서 편집해도 괜찮음
- 버그 찾기 도구를 작성하고 자주 실행하자

