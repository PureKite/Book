# Chapter01. 맛보기 예제

.맛보기 프로그램 설명(ch.one.original)
- Customer 클래스의 statement 메서드에 지나치게 많은 기능이 들어 있는데, 그 중 대부분의 기능은 다른 두 클래스에 들어가야함
- 설계가 조잡한 시스템은 어디를 수정해야 하는지 찾기 힘들어 수정도 어려움
- 수정할 위치를 찾기 힘들면 프로그래머가 실수할 가능성이 높아져서 버그가 생김
- 현재 statemetn 메서드의 어느 기능도 HTML 내역 출력에 재사용할 수 없음
** 내역을 HTML로 출력하게 만들 유일한 임시방편은 statement 메서드와 대부분의 기능이 같은 새 메서드를 작성하는 것
** 하지만, 대여료 적용 규칙이 수정되면 메서드를 둘 다 똑같이 수정해야함
** 즉, 코드를 복사해서 붙이게 되면 나중에 그 코드를 수정할 때마다 계속 같은 여러 부분을 복사해서 붙여야 하기 때문에 아주 번거롭고 에러가 생길 수도 있음
- 앞으로 영원히 수정할 일이 없는 프로그램이라면 복사해서 붙여도 문제가 없지만, 사용 기간이 길고 추후 수정해야 할 가능성이 있는 프로그램은 복사해서 붙이는 과정에서 큰 문제가 생길 수 있음
- 프로그램에 기능을 추가해야 하는데 코드 구조가 조잡해서 그 기능을 추가하기 힘들다면, 우선 리팩토링을 실시해서 기능을 추가하기 쉽게 만든 후 그 기능을 추가하자

.리팩토링 첫 단계
- 리팩토링할 코드 부분에 대한 신뢰도 높은 각종 테스트를 작성하는 것
- 테스트는 반드시 자체검사로 만들어야 함.
** 그렇지 않으면 여러 테스트를 일일이 비교 검사하느라 시간이 낭비됨

.statement 메서드 분해와 기능 재분배
 코드를 잘게 쪼개면 관리도 편하고 다른 코드와 연동하거나 이리저리 옮기기도 쉬움

* 긴 메서드를 분리해서 각 부분을 알맞은 클래스로 옮기는 것
* 중복 코드를 줄이고 HTML로 내역을 출력하는 statement 메서드를 좀 더 간편하게 작성

.논리적 코드 뭉치를 찾아 메서드 추출(Extract Method) 기법 적용
* statement method -> swtich문
* 메서드를 잘못 추출하면 프로그램에 버그가 생길 수 있으니 리팩토링을 적용하기 전에 문제없이 추출할 방법부터 찾기
* 메서드 안에서만 효력이 있는 모든 지역변수와 매개변수에 해당하는 부분을 살펴봐야 함
** each 변수 : 코드로 인해 변경되지 않음 => 변경되지 않는 변수는 매개변수로 전달할 수 있음
** thisAmount 변수 : 코드로 인해 변경됨 => 변경되는 변수는 주의해야함. 변경되는 변수가 하나뿐이라면 그 변수를 반환할 수 있음
** 임시변수는 루프를 한 번 돌 때마다 0으로 초기화, switch문에 진입할 때까지 변경되지 않음
** 그 결과를 그냥 대입하면 됨

.변수명 수정
* 좋은 코드는 그것이 무슨 기능을 하는지 분명히 드러나야 하는데, 코드의 기능을 분명히 드러내는 열쇠가 바로 직관적인 변수명
* 용도가 확실히 드러나게 코드를 작성하는 것은 아주 중요한 일

.대여료 계산 메서드 옮기기 => 메서드 이동(Move Method)
* amountFor 메서드를 보면 Rental 클래스의 정보를 이용하고 정작 자신이 속한 Customer 클래스의 정보는 이용하지 않음
* 메서드는 대체로 자신이 사용하는 데이터와 같은 객체에 들어 있어야 하기 때문에 잘못된 객체에 들어 있는 건 아니지 의심
* Rental 클래스로 옮기기
* 클래스에 맞게 수정한다는 것은 매개변수 삭제를 뜻함, 메서드를 옮기면서 메서드명도 바꿈

.임시변수를 메서드 호출로 전환(Replace Temp with Query)
* thisAmount 변수의 불필요한 중복 => 변수를 삭제
** each.charge 메서드의 결과를 저장하는데만 사용되고 그 후엔 전혀 사용되지 않음
* 임시변수는 최대한 없애는 것이 좋음
** 임시변수가 많으면 불필요하게 많은 매개변수를 전달하게 되는 문제가 흔히 생김
** 긴 메서드 안에서 알게 모르게 늘어나는데, 성능이 떨어짐

.적립 포인트 계산을 메서드로 빼기 => 메서드 추출
- frequentRenterPoints 임시변수가 사용
- frequentRenterPoints 변수에는 이미 값이 들어있음
- 하지만 추출한 메서드안의 코드는 이 값을 읽을 수 없으니 대입문을 추가로 작성하면 frequentRenterPoints 임시변수를 매개변수로 전달할 필요가 없음

.임시변수 없애기
- totalAmount 변수와 frequentRentalPoints 변수를 질의 메서드로 고치기
- 질의 메서드? 클래스 안의 모든 메서드에서 접근 가능하므로, 메서드를 복잡하게 만드는 임시변수를 사용하지 않아도 됨
- Customer 클래스의 totalAmount 변수 => getTotalCharge 메서드로 교체
- 문제점 : while문으로 성능이 저하 => 최적화 단계에서 생각하기

.새로운 요구 조건
- 대여점의 비디오 분류 변경
- 분류를 어떻게 변경할지는 아직 결정하지 않았지만, 기존과 전혀 다른 방식으로 분류
- 수정하는 각 비디오 분류마다 대여료와 적립 포인트의 적립 비율도 결정해야함

.가격 책정 부분의 조건문을 재정의로 교체
- switch문의 인자로 하는 것은 나쁜 방법
- switch문의 인자로는 타 객체 데이터를 사용하지 말고 자신의 데이터를 사용해야함
- 대여 기간을 Rental 클래스에 전달하지 않고 Movie 클래스에 전달했는데 왜??
** 사용자가 요청한 변경은 단지 새로운 비디오 종류를 추가해 달라는 것이었기 때문
** 대체로 비디오 종류에 대한 정보는 나중에 변경할 가능성이 높음
** 비디오 종류를 변경해도 그로 인해 미치는 영향을 최소화하고자 대여료 계산을 Movie 클래스 안에 넣은 것
- 적립 포인트 계산 메서드도 Movie 클래스로 옮기기
** 비디오 종류마다 달라지는 대여료와 적립 포인트 계산이 비디오 분류가 든 클래스 자체에서 처리됨

.상속 구조 만들기
- Movie 클래스는 비디오 종류에 따라 같은 메서드 호출에도 각기 다른 값을 반환함
** 이건 하위클래스가 처리할 일
- Movie 클래스를 상속받는 3개의 하위클래스를 작성하고, 비디오 종류별 대여료 계산을 각 하위클래스에 넣어야 함
** 수명주기 동안 비디오는 언제든 분류가 바뀔 수 있지만 객체는 수정이 불가능하므로 불일치가 발생하지만 상태 패턴을 적용해 switch문을 삭제하면 됨
- 인다이렉션 기능을 추가하면 Price 클래스 안의 코드를 하위클래스로 만들어서 언제든 대여료를 변경할 수 있음
- 상태 패턴을 적용하려면 세 가지 리팩토링 기법을 사용해야 함
1. 분류 부호를 상태/전략 패턴으로 전환(Replace Type Code with State/Strategy) 기법을 실시해서 분류 부호의 기능을 상태 패턴 안으로 옮기기
* 분류 부호에 필드 자체 캡슐화(Self Encapsulate Field) 기법 적용해서 반드시 읽기/쓰기 메서드를 거쳐서만 분류 부호 사용
2. 메서드 이동(Move Method) 기법을 실시해서 switch 문을 Price 클래스 안으로 옮기기
3. 조건문을 재정의로 전환(Replace Conditional with Polymorphism) 기법을 실시해서 switch 문 없애기

.상태 패턴을 적용하는 이유
- 대여료 계산 방식을 변경하거나, 새 대여료를 추가하거나, 부수적인 대여료 관련 동작을 추가할 때 아주 쉽게 수정할 수 있음
- 프로그램의 다른 부분은 상태 패턴의 영향을 받지 않음