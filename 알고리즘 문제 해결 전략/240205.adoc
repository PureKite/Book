= 1. 문제 해결 시작하기

.프로그래밍은 문제 해결이다.
* 프로그램이 사용할 수 있는 최대 메모리와 사용자가 답답해하지 안헥 하기 위한 시간 제한도 유의해야 하고, 가능한 재사용성이 높은 간결한 코드를 작성
* 프로그래머가 사용하는 언어나 라이브러리, 알고리즘에 대한 지식들이 퍼즐의 조각이라면 문제 해결 능력은 적재적소에 퍼즐 조각을 배치하고 이들을 연결해서 큰 그림을 만드는 능력

.프로그래밍 대회를 위한 여섯 단계 문제 해결 알고리즘
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

.문제 해결 전략
* 직관과 체계적인 접근
** 체계적인 접근을 위한 질문들
1. 비슷한 문제를 풀어본 적이 있던가?
- 이전에 적용했던 방법과 비슷한 접근 방법을 사용할 거라고 예측할 수 있음
- 기존에 접했던 문제가 온전히 경험이 되려면 그 원리를 완전히 이해하고 변형할 수 있어야 함
2. 단순한 방법에서 시작할 수 있을까?
- 간단하게 풀 수 있는 문제를 너무 복잡하게 생각해서 어렵게 푸는 실수를 예방하는 것
- 좀더 효율적인 자료 구조를 사용하거나, 계산과정에서 같은 정보를 두 번 중복으로 계산하지 않는 등의 최적화를 적용해 알고리즘을 개선하는 식으로도 문제 풀기가 가능
3. 내가 문제를 푸는 과정을 수식화할 수 있을까?
4. 문제를 단순화할 수 없을까?
- 문제의 제약 조건을 없앨 수도 있고, 계산해야 하는 변수의 수를 줄일 수도 있으며, 다차원의 문제를 1차원으로 줄여서 표현할 수도 있음
5. 그림으로 그려볼 수 있을까?
6. 수식으로 표현할 수 있을까?
7. 문제를 분해할 수 있을까?
- 더 다루기 쉬운 형태로 문제를 변형하는 것
- 문제에 주어진 복잡한 조건을 더 단순한 형태를 갖는 조건의 집합으로 분해
8. 뒤에서부터 생각해서 문제를 풀 수 있을까?
- 문제에 내재된 순서를 바꿔보는 것
9. 순서를 강제할 수 있을까?
- 8번의 연장선으로, 순서가 없는 문제에 순서를 강제해서 문제를 푸는 방법
10. 특정 형태의 답안을 고려할 수 있을까?
- 9번의 연장선으로, 정규화 기법

.좋은 코드를 짜기 위한 원칙
* 간결한 코드를 작성하기
** 코드가 짧으면 짧을수록 오타나 단순한 버그가 생길 우려가 줄어들고, 디버깅도 쉬워짐
** 일반적인 프로그램에서는 권장할 수 없지만, 작성하는 프로그램이 짧고 그 용도가 제한되어 있는 프로그래밍 대회의 특성상 잘 가려 사용하면 유용
*** 대표적인 예) 전역 변수의 광범위한 사용
*** 전역 변수를 많이 사용하면 프로그램의 흐름을 파악하기 어려워지지만 프로그래밍 대회에서 작성하는 코드는 구조가 매우 단순하고, 각 변수를 읽고 쓰는 부분이 어디인지가 비교적 명확하기 때문에 전역변수를 쓰더라도 잃는 것이 그렇게 많지 않음
* 적극적으로 코드 재사용하기
** 코드를 모듈화하는 것
** 같은 코드가 반복된다면 이들을 함수나 클래스로 분리해 재사용하는 것
** 시간이 업삳고 해서 코드를 더 알기 쉽게 고치는 데 주저해서는 안 됨
** 항상 코드를 깔끔하게 작성하고 유지하는 데 신경을 쓰다 보면 스스로가 그와 같은 코드에 익숙해지기 때문임
** 그렇다고 해서 실무에서 작성하듯 코드를 작성할 수는 없음(Single Responsible Principle)
* 표준 라이브러리 공부하기
** 언어의 문자열, 동적배열, 스택, 큐, 리스트, 사전 등의 자료 구조, 그리고 정렬 등의 표준적인 알고리즘 구현 사용법을 반드시 잘 알아 두기
* 항상 같은 형태로 프로그램을 작성하기
* 일관적이고 명료한 명명법 사용하기
** 모호하지 않은 변수명과 함수명을 사용하는 버릇을 들이고, 사용하는 언어의 표준 라이브러리에서 사용하는 명명 규약을 익히기
* 모든 자료를 정규화해서 저장하기
** 같은 자료를 두 가지 형태로 저장하지 않는 것
* 코드와 데이터를 분리하기

.자주 하는 실수
* 산술 오버플로
* 배열 범위 밖 원소에 접근
* 일관되지 않은 범위 표현 방식 사용하기
** 대부분의 프로그래밍 언어는 반 열린 구간(half-open interval)을 사용
** 자연어에서 사용하는 범위와 다르다는 이유 때문에 문제가 생기는 경우가 종종 있음
*** 문제를 피하기 위해서는 프로그램 내에서 한 가지 방법으로만 범위를 표현할 필요가 있음
*** 프로그래밍 언어가 지원하는 범위 표현 방식을 따르는 것이 가장 효율적
* Off-by-one 오류
** 계산의 큰 줄기는 맞지만 하나가 모자라거나 하나가 많아서 틀리는 코드의 오류들을 모두 가르킴
** 반복문에서 < 혹은 > 연산자와 <= 혹은 >= 연산자를 혼동하여 원소를 하나 더 적게, 혹은 많이 순회하는 경우나 반 열린 구간과 닫힌 구간을 서로 혼용해 쓴 경우 흔하게 발생
** 최소 입력이 주어졌을 때 이 코드가 어떻게 동작할지를 되새겨 보면서 프로그램을 짜는 것
* 컴파일러가 잡아주지 못하는 상수 오타
* 스택 오버플로
** 프로그램의 실행 중 콜 스택이 오버플로해서 프로그램이 강제종료 되는 것
** 대개 재귀 호출의 깊이가 너무 깊어져서 오기 때문에 유의하기
* 다차원 배열 인덱스 순서 바꿔 쓰기
** 고차원 배열을 쓰게 되면 인덱스의 순서를 헷갈려서 잘못 쓰는 경우
** 가능한 한 특정 배열에 접근하는 위치를 하나로 통일하는 것이 좋음
* 잘못된 비교 함수 작성
1. a < a는 항상 거짓 => 비반사성(irreflexivity)
2. a < b가 참이면 b < a는 거짓 => 비대칭성(asymmetry)
3. a < b가 참이고 b < c가 참이면 a < c 다. => 전이성(transitivity)
4. a < b와 b < a가 모두 거짓이면 a와 b는 같은 값으로 간주. a와 b가 같고, b와 c가 같다면 a와 c도 같아야함 => 상등 관계의 전이성(transitivity of equivalence)
** 자바의 표준 라이브러리가 < 연산 대신에 <= 연산을 비교 함수의 모델로 쓴다는 것
*  최소, 최대 예외 잘못 다루기
** 예외 : 우리가 예상한 입력의 규칙에 들어맞지 않는 모든 입력
** 예외를 제대로 처리하지 못한 경우라는 말은 너무 모호해서 일반적인 시수라고 하기 힘들지만 가능한 입력 중 최소 값과 최대 값이 예외가 되는 문제들은 생각 외로 많음
* 연산자 우선순위 잘못 쓰기
** 연산자의 우선순위들을 잘 기억해 두거나, 헷갈릴 경우에는 괄호로 적절히 감싸기
* 너무 느린 입출력 방식 선택
* 변수 초기화 문제

.디버깅
* 작은 입력에 대해 제대로 실행되나 확인하기
* 단정문 사용
** 단정문? 주어진 조건이 거짓일 때 오류를 내고 프로그램을 강제 종료시키는 함수 또는 구문
** 주어진 조건이 참일 때는 무시되고, 거짓일 때만 오류를 내므로 프로그램의 내부 상태를 검증할 때 유용하게 쓸 수 있음
** 프로그램의 계산 중간 결과 출력
* 런타임 오류를 내고 종료하는 경우에 디버거 사용하기

.테스트
* 주어진 예제 입력을 약간 바꿔서 넣어 보거나, 있을 수 있는 가장 작은 입력과 가장 큰 입력을 만들어서 넣어 보고 시간 안에 실행되는지, 답은 잘 나오는지 테스트
* 스캐폴딩? 다른 코드를 개발할 때 뼈대를 잡기 위해 임시로 사용하는 코드
** 코드의 정당성을 확인하거나 반례를 찾는데 유용
** 코드의 모든 문제를 찾아낼 수는 없음

.변수 범위의 이해
* 산술 오버플로
** 컴퓨터는 수학자들이 만든 기계이며 수학에 따라 움직입니다만, 현실 세계에 존재하는 물건인지라 엄연한 제한이 있음 => 대표적인 제한 : 유한성
** 컴퓨터의 모든 변수에는 담을 수 있는 크기가 제한되어 있음
** 수학적/논리적으로는 완전히 정당한 알고리즘도 프로그램으로 구현했을 때는 예상과 다르게 동작하는 경우를 흔하게 볼 수 있음
** 어떤 식의 계산 값이 반환되는 자료형의 표현 가능한 범위를 벗어나는 경우 => 산술 오버플로
1. 대부분의 프로그래밍 언어들은 사칙연산 과정에서 오버플로가 나더라도 별다른 경고를 하지않음
2. 프로그램의 정당성을 검증할 때 프로그램 논리의 정확성에만 집중하다 보면 산술 오버플로가 등장할 수 있다는 사실을 잊기 쉬움
* 너무 큰 결과
** 변수의 형태에 주의하는 습관 들이기
* 너무 큰 중간 값
** 프로그램의 출력 값의 범위는 작지만 중간 과정에서 큰 값을 일시적으로 계산해야 하는 경우
* 너무 큰 '무한대' 값
** 무한대 값을 선택할 때는 이 무한대 값들이 서로 더해지거나 곱해지는 경우가 없는지 잘 살펴보고 오버플로가 나지 않을 크기의 값을 선택하는 것이 좋음
* 오버플로 피해가기
** 더 큰 자료형 쓰기
** 오버플로가 나지 않도록 연산의 순서를 바꾸는 것
* 자료형의 프로모션
** 피연산자의 자료형이 다르거나 자료형의 범위가 너무 작은 경우 컴파일러들은 대개 이들을 같은 자료형으로 변환해서 계산 => 프로모션
** 프로모션은 대부분의 경우에는 신경 쓸 필요가 없지만, 가끔 알기 어려운 버그를 만드는 주역이 됙도 함

.실수 자료형의 이해 (복습 필수!!)
* 실수와 근사 값
** 모든 것이 셀 수 있고 단위가 정해져 있는 정수들과는 달리 실수를 다루게 되면 일상 생활에서도 무한의 세계로 날아가 버리게 됨
** 컴퓨터의 메모리는 항상 유한하고, 이 모든 값들을 모두 정확하게 담을 수는 없으니 어쩔 수 없이 적절히 비슷한 값을 사용하는 것으로 만족해야함
** 정수의 수식은 몇 번을 계산하더라도 같은 값이 반환되지만, 실수의 계산에서는 같은 수식을 두 번 계산하더라도 어떤 순서로 계산하는지, 컴파일러 최적화는 켰는지, 로그 메시지를 출력 하는지 여부에 따라서 답이 달라질 수 있음
** 컴퓨터가 사용하는 실수 표현 방식과 그 장단점을 이해해야만 함
* IEEE 754 표준
** 이진수로 실수를 표기
** 부동 소수점 표기법
** 무한대, 비정규 수 등의 특수한 값이 존재
* 실수 비교하기
1. 비교할 실수의 크기들에 비례한 오차 한도를 정한다.
2. 상대 오차를 이용한다.
* 대소 비교
** 두 수가 같은지를 판단하는 것이 아니라 대소를 판단할 때도 연산 오차가 발목을 잡을 수 있음
** 두 값이 아주 가까운 경우를 먼저 확인하고 처리해줌
* 정확한 사칙연산
* 코드의 수치적 안정성 파악하기
** 프로그램의 실행 과정에서 발생하는 오차가 더 커지지 않는다는 말
* 실수 연산 아예 하지 않기
** 실수 연산을 써야만 할 것 같은 문제들에 적절한 변형을 가해 실수 연산을 없앨 수 있음



